---
marp: true
theme: espressif_devcon_2023
headingDivider: 1
---
<!-- _class: lead -->

# Async Rust for embedded systems

## Scott Mabin, Juraj Sadel

# Goals of this presentation
* Explore how async Rust works
* Apply it to an embedded context
* Create a working application using async Rust
# Why use async?
* Single-threaded concurrency (multitasking), doing multiple things at once without needing threads
* Can run on a single stack, great for microcontrollers
* Composability of async/await instead of manually writing state machines.
# A refresher on async Rust syntax

Last year's talk: [EDC22 Day 1 Talk 7: Rust on Espressif chips](https://www.youtube.com/watch?v=qeEmJ_-6fPg).

`async` in Rust adds two new keywords to the language, `async` & `await` , where

 - `async` defines a block or function to be asynchronous
 - `await` defines yield points _within_ an `async` block or function.

# `async` & `.await`

* Building blocks for async blocks, closures, and functions that can be paused and yield control back to the caller
* `async` code returns a value that implements the `Future` trait

```rust
pub async fn say_hello(uart0: &mut Serial<UART0>) {
  let message = "Hello World!";
  uart0.write_bytes(message).await; // yield point here!
  let message = "Goodbye";
  uart0.write_bytes(message).await; // another yield point here!
}
```

# Busy Loop
* Repeatedly checks for a condition to be true before proceeding
* Simple to implement, very inefficient

```rust
    let io = IO::new(peripherals.GPIO, peripherals.IO_MUX);
    let mut led = io.pins.gpio7.into_push_pull_output();
    let button = io.pins.gpio9.into_pull_up_input();

    loop {
        if button.is_high().unwrap() {
            led.set_high().unwrap();
        } else {
            led.set_low().unwrap();
        }
    }
```

# Interrupt - main loop

```rust
static BUTTON: Mutex<RefCell<Option<Gpio9<Input<PullDown>>>>> = Mutex::new(RefCell::new(None));
static STATE: AtomicBool = AtomicBool::new(false);
fn main() {
    let mut led = io.pins.gpio7.into_push_pull_output();
    let mut button = io.pins.gpio9.into_pull_down_input();
    button.listen(Event::FallingEdge);
    button.listen(Event::RisingEdge);

    critical_section::with(|cs| BUTTON.borrow_ref_mut(cs).replace(button));
    interrupt::enable(peripherals::Interrupt::GPIO, interrupt::Priority::Priority3).unwrap();

    loop {
        if STATE.load(Ordering::SeqCst) {
            led.set_high().unwrap();
        } else {
            led.set_low().unwrap();
        }
        sleep(); // wait for interrupt here
    }
}
```

# Interrupt - handler

```rust
#[interrupt]
fn GPIO() {
    critical_section::with(|cs| {
        let button = BUTTON.borrow_ref_mut(cs).as_mut().unwrap();
        button.clear_interrupt();
        if button.is_high().unwrap() {
            STATE.store(true, Ordering::SeqCst);
        } else {
            STATE.store(false, Ordering::SeqCst);
        }
    });
}
```

# Interrupt 
* Hardware signal that interrupts the normal flow of programs execution
* Allows sleeping in the main thread
* More code is required, harder to write and read the code
# Async

```rust
static EXECUTOR: StaticCell<Executor> = StaticCell::new();

fn main() {
    let io = IO::new(peripherals.GPIO, peripherals.IO_MUX);
    let mut output = io.pins.gpio7.into_push_pull_output();
    let input = io.pins.gpio9.into_pull_down_input();
    let executor = EXECUTOR.init(Executor::new());
    
    executor.run(|spawner| {
        spawner.spawn(toggle(input, output)).ok();
    });
}

async fn toggle(mut input: Gpio9<Input<PullDown>>, mut output: Gpio7<Output<PushPull>>) {
    loop {
        match select(
            input.wait_for_rising_edge().await.unwrap(),
            input.wait_for_falling_edge().await.unwrap(),
        ) {
            Either::First(_) => output.set_high(),
            Either::Second(_) => output.set_low(),
        }
    }
}
```

# Async
* higher-level approach used to handle multiple tasks without resorting a busy wait
* Structurally, it's similar to a `busy loop` but with `async`, each `await` point allows the CPU to do something else, or even sleep so save power.
# How does it work?

You can only `await` something that implements the `Future` trait.

The `Future` trait has one required method, `poll` which returns either `Poll::Ready(_)` if the asynchronous operation is complete, or `Poll::Pending` if it needs to be polled again later.

# Implementing the Future trait

<!-- - asynchronous computation that can produce (even empty - ()) value
* calling `poll()`, if the future completes,  `Poll::Ready(result)` is returned
* `Poll::Pending` is returned if future is not ready yet,  `wake()` call has to be arranged to call whe the `Future` is ready to make more progress
* the `executor` will call `poll()` again when `wake()` is called
* the executor knows via `wake()` which Futures are ready to be `poll`ed again -->

```rust
pub trait Future {
    type Output;

    // Required method
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}
```

```rust
enum Poll<T> {
    Ready(T),
    Pending,
}
```

* Returns `Poll::Ready(_)` if the `Future` has resolved.

<!-- 

```rust
pub struct SocketRead<'a> {
    socket: &'a Socket,
}

impl Future for SocketRead<'_> {
    type Output = Vec<u8>;

    fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
        if self.socket.has_data_to_read() {
            // The socket has data -- read it into a buffer and return it.
            Poll::Ready(self.socket.read_buf())
        } else {
            // The socket does not yet have data.
            //
            // Arrange for `wake` to be called once data is available.
            // When data becomes available, `wake` will be called, and the
            // user of this `Future` will know to call `poll` again and
            // receive data.
            self.socket.set_readable_callback(wake);
            Poll::Pending
        }
    }
}
``` -->

# When to poll?

You _could_ just `poll` the future in a hot loop, but this is not very efficient and will block other `async` operations from running.

```rust
while let Poll::Pending = some_fut.poll() {
    // 100% CPU used here waiting for `Poll::Ready(_)`
}
```

Ideally, we'd like to do other things until the `async` operation is ready. This is where the `Waker` concept is introduced.

# The `Waker`

A `Waker` is something that can be used to signal that a future should be polled again.

`wake`ing a `Waker` can happen from anywhere, some examples being an interrupt handler, a call back function or just another function.

# Example: Async Queue

```rust
pub struct AsyncQueue {
    recv: Waker,
    // other storage implementation details
    // send waker ommited for simplicity
}
```

```rust
impl AsyncQueue {

    pub fn recv(&self) {
        // register self.recv waker ==> `Poll:Pending` ==> yield execution until `wake()` is called
    }

    pub fn send(&self) {
        // call self.recv.wake() to poll the recv future again
    }
}
```

# How to run futures - Executors

We've covered how futures work, but where do `Poll::Pending` futures yield to? They yield back to the _executor_.

The executor is the mechanism to run futures, it handles the response to a `wake` event and then `poll` 's that future again.

Executor is a general term, there is no trait for them, they can be implemented in various ways and each will have various features and limitations.

<!-- SPEAKERS note:

    A tip for developers: an executor is allowed to poll a future anytime, it is up to the logic in the `Future` implementation to ensure the operation is complete.

 -->

# Embedded async - embassy

A popular executor for embedded systems is the embassy project. It aims to provide, not just an executor, but a collection of tools and utilities to create effective async applications.

```rust
#[embassy_executor::task]
async fn ping(mut pin: Gpio9<Input<PullDown>>) {
    loop {
        esp_println::println!("Waiting...");
        pin.wait_for_rising_edge().await.unwrap();
        esp_println::println!("Ping!");
        Timer::after(Duration::from_millis(100)).await;
    }
}
```

<!-- SPEAKER NOTES

    Embassy only requires a time driver impl for async delays, if you have your own async delay then this is not needed

 -->

# Async tasks in embassy

Usually, the top-level future is called a task. Within the task, many futures could be `await` ed. In embassy, tasks are statically allocated to avoid the need for an allocator. The `#[embassy_executor::task]` macro takes care of this for us.

Tasks are allowed to have infinite loops, much like a traditional RTOS task, but **MUST** contain at least one `await` point to avoid blocking other tasks.

```rust
#[embassy_executor::task]
async fn task() {
    loop {
        Timer::after(Duration::from_millis(100)).await;
    }
}
```

<!-- SPEAKER NOTES

    Mention that you can allocate and spawn tasks dynamically with other executors?

 -->

# Building an async wifi data logger

<!-- TODO -->

# The road ahead

<!-- Where do we go from here, future work etc -->

# Resources

<!-- Any links to further reading etc -->
