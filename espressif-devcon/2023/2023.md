---
marp: true
theme: espressif_devcon_2023
headingDivider: 1
---
<!-- _class: lead -->
# Async Rust for embedded systems
## Scott Mabin, Juraj Sadel, Bjoern Quentin

# Goals of this presentation

- Explore how async Rust works
- Apply it to an embedded context
- Create a working application using async Rust

# A refresher on async Rust syntax

Last year's talk: [EDC22 Day 1 Talk 7: Rust on Espressif chips](https://www.youtube.com/watch?v=qeEmJ_-6fPg).

`async` in Rust adds two new keywords to the language, `async` & `await`, where

 - `async` defines a block or function to be asynchronous
 - `await` defines yield points _within_ an `async` block or function.

## async/.await

- building blocks for async blocks, closures, and functions that can be paused and yield control back to the caller
- `async` defines blocks, closures, and functions to be asynchronous
- `await` defines a yield point within `async` code
- `async` code returns a value that implements the `Future` trait

```rust
pub async fn say_hello(uart0: &mut Serial<UART0>) {
  let message = "Hello World!";
  uart0.write_bytes(message).await; // yield point here!
  let message = "Goodbye";
  uart0.write_bytes(message).await; // another yield point here!
}
```

## Implementing the Future trait

- asynchronous computation that can produce (even empty - ()) value
- calling `poll()`, if the future completes, `Poll::Ready(result)` is returned
- `Poll::Pending` is returned if future is not ready yet, `wake()` call has to be arranged to call whe the `Future` is ready to make more progress
- the `executor` will call `poll()` again when `wake()` is called
- the executor knows via `wake()` which Futures are ready to be `poll`ed again

```rust
pub trait Future {
    type Output;

    // Required method
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}

enum Poll<T> {
    Ready(T),
    Pending,
}
```

- read data from a socket that may or may not have data available already
- if data is available we can read them and return `Poll::Ready(data)`, if not our future is blocked
- the `wake()` has to be registered and called when data are ready

```rust
pub struct SocketRead<'a> {
    socket: &'a Socket,
}

impl SimpleFuture for SocketRead<'_> {
    type Output = Vec<u8>;

    fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
        if self.socket.has_data_to_read() {
            // The socket has data -- read it into a buffer and return it.
            Poll::Ready(self.socket.read_buf())
        } else {
            // The socket does not yet have data.
            //
            // Arrange for `wake` to be called once data is available.
            // When data becomes available, `wake` will be called, and the
            // user of this `Future` will know to call `poll` again and
            // receive data.
            self.socket.set_readable_callback(wake);
            Poll::Pending
        }
    }
}
```

# Why use async?

- Single-threaded concurrency (multitasking), doing multiple things at once without needing threads
- Can run on a single stack, great for microcontrollers
- Composability of async/await instead of manually writing state machines.

## Busy Loop

- repeatedly checks for condition to be true before proceeding
- simple to implement, very inefficient

```rust
    let io = IO::new(peripherals.GPIO, peripherals.IO_MUX);
    let mut led = io.pins.gpio7.into_push_pull_output();
    let button = io.pins.gpio9.into_pull_up_input();

    loop {
        if button.is_high().unwrap() {
            led.set_high().unwrap();
        } else {
            led.set_low().unwrap();
        }
    }
```

## Interrupt

- hardware signal that interrupts the normal flow of program's execution
- more code required, harder to write and read the code, efficient

```rust
    static BUTTON: Mutex<RefCell<Option<Gpio9<Input<PullDown>>>>> = Mutex::new(RefCell::new(None));
    // inside main()
    let mut led = io.pins.gpio7.into_push_pull_output();

    // Set GPIO9 as an input
    let mut button = io.pins.gpio9.into_pull_down_input();
    button.listen(Event::FallingEdge);

    critical_section::with(|cs| BUTTON.borrow_ref_mut(cs).replace(button));

    interrupt::enable(peripherals::Interrupt::GPIO, interrupt::Priority::Priority3).unwrap();

    unsafe {
        riscv::interrupt::enable();
    }

    let mut delay = Delay::new(&clocks);
    loop {
        led.toggle().unwrap();
        delay.delay_ms(500u32);
    }
    // end of main()

    #[interrupt]
    fn GPIO() {
        critical_section::with(|cs| {
            println!("GPIO interrupt");
            BUTTON
                .borrow_ref_mut(cs)
                .as_mut()
                .unwrap()
                .clear_interrupt();
        });
    }
```

## Async

- higher-level approach used to handle multiple tasks without resorting the busy wait
- syntax-wise it's similar to the `busy loop` with `async/.await` but it is more efficient

```rust
    #[embassy_executor::task]
    async fn ping(mut pin: Gpio9<Input<PullDown>>) {
        loop {
            pin.wait_for_rising_edge().await.unwrap();
            Timer::after(Duration::from_millis(100)).await;
        }
    }

    static EXECUTOR: StaticCell<Executor> = StaticCell::new();

    // inside main()
    let io = IO::new(peripherals.GPIO, peripherals.IO_MUX);
    // GPIO 9 as input
    let input = io.pins.gpio9.into_pull_down_input();

    // Async requires the GPIO interrupt to wake futures
    esp32c3_hal::interrupt::enable(
        esp32c3_hal::peripherals::Interrupt::GPIO,
        esp32c3_hal::interrupt::Priority::Priority1,
    )
    .unwrap();

    let executor = EXECUTOR.init(Executor::new());
    executor.run(|spawner| {
        spawner.spawn(ping(input)).ok();
    });
// end of main()
```

# How does it work?

You can only `await` something that implements the `Future` trait.

The `Future` trait has one required method, `poll` which returns either `Poll::Ready(_)` if the asynchronous operation is complete, or `Poll::Pending` if it needs to be polled again later.

# When to poll?

You _could_ just `poll` the future in a hot loop, but this is not very efficient and will block other `async` operations from running.

```rust
while let Poll::Pending = some_fut.poll() {
    // 100% CPU used here waiting for `Poll::Ready(_)`
}
```

Ideally, we'd like to do other things until the `async` operation is ready. This is where the `Waker` concept is introduced.

# The `Waker`

A `Waker` is something that can be used to signal that a future should be polled again.

`wake`ing a `Waker` can happen from anywhere, some examples being an interrupt handler, a call back function or just another function.

# Example: Async Queue

```rust
pub struct AsyncQueue {
    recv: Waker,
    // other storage implementation details
    // send waker ommited for simplicity
}
```

```rust
impl AsyncQueue {

    pub fn recv(&self) {
        // register self.recv waker ==> `Poll:Pending` ==> yield execution until `wake()` is called
    }

    pub fn send(&self) {
        // call self.recv.wake() to poll the recv future again
    }
}
```

# How to run futures - Executors

We've covered how futures work, but where do `Poll::Pending` futures yield to? They yield back to the _executor_.

The executor is the mechanism to run futures, it handles the response to a `wake` event and then `poll`'s that future again.

Executor is a general term, there is no trait for them, they can be implemented in various ways and each will have various features and limitations.

<!-- SPEAKERS note:
    A tip for developers: an executor is allowed to poll a future anytime, it is up to the logic in the `Future` implementation to ensure the operation is complete.
 -->

# Embedded async - embassy

A popular executor for embedded systems is the embassy project. It aims to provide, not just an executor, but a collection of tools and utilities to create effective async applications.

```rust
#[embassy_executor::task]
async fn ping(mut pin: Gpio9<Input<PullDown>>) {
    loop {
        esp_println::println!("Waiting...");
        pin.wait_for_rising_edge().await.unwrap();
        esp_println::println!("Ping!");
        Timer::after(Duration::from_millis(100)).await;
    }
}
```

<!-- SPEAKER NOTES
    Embassy only requires a time driver impl for async delays, if you have your own async delay then this is not needed
 -->

# Async tasks in embassy

Usually, the top-level future is called a task. Within the task, many futures could be `await`ed. In embassy, tasks are statically allocated to avoid the need for an allocator. The `#[embassy_executor::task]` macro takes care of this for us.

Tasks are allowed to have infinite loops, much like a traditional RTOS task, but **MUST** contain at least one `await` point to avoid blocking other tasks.

```rust
#[embassy_executor::task]
async fn task() {
    loop {
        Timer::after(Duration::from_millis(100)).await;
    }
}
```
<!-- SPEAKER NOTES
    Mention that you can allocate and spawn tasks dynamically with other executors?
 -->


# Building an async wifi data logger

<!-- TODO -->


# The road ahead

<!-- Where do we go from here, future work etc -->

# Resources

<!-- Any links to further reading etc -->

